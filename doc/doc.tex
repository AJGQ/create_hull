\documentclass[11pt]{article}
\usepackage{amssymb}
\usepackage{amsmath}
%\usepackage[all]{xy}

\title{Algoritmo para gerar invólucros convexos}
\author{Artur Queiroz - PG38014\\Luís Albuquerque - PG38015}
\begin{document}
\maketitle

\section{Introdução}
Neste trabalho abordamos um dos principais temas de Geometria 
Computacional, Invólucros Convexos.
Estes são muito usados porque têm aplicações em bastantes àreas
como reconhecimento de padrões, processamento de imagem, 
estatística, etc.

Existem várias formas de construir um, mas neste trabalho vamos
nos cingir a implementar o "\textit{merge-hull}"
que é um algoritmo que se usa, umas das técnicas mais importantes
na computação, que se chama "Dividir para conquistar".
Baseia-se em dividir um problema complexo, em problemas mais 
pequenos e mais faceis.

\subsection{Notações utilizadas}
$<\forall x : p(x) : q(x)>$ é equivalente a $\forall_{p(x)} . q(x)$

%--------------------------------------------
%\clearpage
\section{Descrição}
Para implementarmos o algoritmo apenas temos que seguir os passos
a baixo.

\begin{itemize}
    \item Ordenar os pontos por ordem lexicográfica.
    \item Remover os pontos repetidos.
    \item Criar o Invólucro convexo
    \begin{itemize}
        \item Se o conjunto tem apenas 1 elemento, criar um "polígono"
            de 1 elemento e acaba-se a função.
        \item Separar os pontos em dois conjuntos A e B, 
            onde A contém os pontos da esquerda e B os da direita.
        \item Calcular o invólucro convexo de A, 
            $\mathcal{A}$ = I(A) e o de B, $\mathcal{B}$ = I(B) recursivamente
        \item Encontrar o pontos de junção.
        \item Juntar $\mathcal{A}$ e $\mathcal{B}$, 
            calculando o invólucro convexo de A $\cup$ B.
    \end{itemize}
\end{itemize}

Agora vamos explicar com mais detalhe todo o processo.
\subsection{ Ordenar os Pontos }
Para ordenar os pontos, pode ser usado qualquer algoritmo de ordenação,
tendo em atenção que a escolha do algoritmo de ordenação, pode alterar a
complexidade do algoritmo como um todo.
Nós optamos por escolher o algoritmo de ordenação \textit{merge sort},
além de ter uma das melhores complexidades $\Theta(n\log{}n)$, achamos 
que se enquadra perfeitamente no espirito do algoritmo, "Dividir para conquistar".

\subsubsection{Descrição de MergeSort}
Input: array, indice esquerdo, indice direito\\

Começando com o indice esquerdo a 0, e o indice direito a (\textit{tamanho do array}) - 1
\begin{itemize}
    \item Primeiro encontra-se o indice médio do Array e divide-se em dois. 
        ( meio = (esquerda + direita)/2 )
    \item Calcular o MergeSort(array, esquerda, meio) (a lista que fica à esquerda)
    \item Calcular o MergeSort(array, meio+1, direita) (a lista que fica à direita)
    \item No final junta os dois de forma ordenada.
\end{itemize}

\subsection{ Remover os Pontos Repetidos }
Já que neste contexto sabemos que o array está ordenado,
podemos fazer este algoritmo com 2 indices, um para percorrer
o array, o outro para percorrer o novo array onde todos os 
elementos são diferentes. Se o valor dos dois indices for
diferente então incrementa-se o segundo indice e atribui-se
o valor do primeiro indice no valor do segundo indice. Se o 
valor dos dois indices for igual, apenas incrementa-se o
primeiro indice.

\subsection{ Separar os Pontos em dois conjuntos }
No trabalho decidimos usar um array, para que a sua divisão a meio 
tivesse uma complexidade constante é tão simples como encontrar o 
índice a meio do array.

\subsection{ Juntar os invólucros convexos } 
Liberta-se a memória dos vértices entre as duas ligações e de seguida 
conecta-se as duas ligações.

%--------------------------------------------

\section{Correção}
Depois de mostrarmos como é o algoritmo,
aqui vamos provar, porque é que o algoritmo faz o que diz que faz.
Tendo I como a nossa função descrita em cima.\\
\par
Queremos que no fim de execução do algoritmo, o poligono
retornado seja o invólucro convexo do conjunto dado 
no input.\par
Para isso vamos usar um Corolário dado nas aulas, descrito como:

\begin{center}
    "Seja $S \subseteq \mathbb{R}^2$ e $P$ um poligono de vértices 
    positivamente orientados $v_0,...,v_{n-1} \in S$ tal que cada
    vértice é estritamente convexo e $S \subseteq P$. Então $P$ é
    o invólucro convexo de S."
\end{center}

E a definição:

\begin{center}
    "$v_i$ diz-se estritamente convexo se $\mathcal{A}(v_{i-1},v_i,v_{i+1}) > 0$."
\end{center}

Seja o input $S$, conjunto de pontos, e o output $P$, poligono.\\
Caso Base ($S = \emptyset$):\par
\hfill\begin{minipage}{\dimexpr\textwidth-1cm}
    Trivial\\
\end{minipage}
Caso Base ($\#S = 1$):\par
\hfill\begin{minipage}{\dimexpr\textwidth-1cm}
    Seja $v_0 \in S$, então pela definição de $I$, $v_0 \in P$\\
\end{minipage}
Caso Indutivo:\par
\hfill\begin{minipage}{\dimexpr\textwidth-1cm}
    Seja $S = S_1 \cup S_2$ tal que todos os pontos de $S_1$
    sejam menores que os pontos de $S_2$ (lexicograficamente); 
    $P_1 = I(S_1)$ e $P_2 = I(S_2)$ em que $P_1$ e $P_2$ são 
    invólucros convexos por indução.\\\\
    
    Suponhamos que os pontos de $S$ são colineares.\\
    Pelas definições de \textit{find\_lower\_lim} e 
    \textit{find\_higher\_lim} vão encontrar as linhas 
    $\overline{p q}$ e $\overline{q p}$, respetivamente,
    tal que p é o ponto menor de S, e q o ponto maior de S. 
    Logo $P = \overline{p q}$, o invólucro convexo de S.\\\\

    Suponhamos que os pontos de $S$ não são colineares.\\
    Agora para provar que $P$ é o invólucro convexo
    do conjunto $S$, basta provar que $P$, com os vértices 
    positivamente orientados, \textbf{todos os vértices 
    são estritamente convexos} e \textbf{todos os vértices 
    estão no poligono}.\\
    
    
    
\end{minipage}

\subsection{Todos os vértices são estritamente convexos}

Hipoteses Indutivas:
\begin{enumerate}
    \item $< \forall p_i : p_i \in I(S_1) : \mathcal{A}(p_{i-1}, p_i, p_{i+1}) > 0 >$
    \item $< \forall p_i : p_i \in I(S_2) : \mathcal{A}(p_{i-1}, p_i, p_{i+1}) > 0 >$
\end{enumerate}

Na função \textit{find\_lower\_lim} começa-se com a linha,
do maior vértice de $I(S_1)$ ao menor vértice de $I(S_2)$ (lexicograficamente).
A partir do vértice atual de $I(S_1)$ segue-se para o anterior, o mais 
longe possível, até que o vértice anterior esteja estritamente à
esquerda da linha, de seguida fazemos o dual para o vértice de $I(S_2)$.
Repetindo este processo até não se conseguir mais.
\par

Quando não conseguirmos mais, significa que encontramos 2 vértices 
$p_i$ e $q_i$, tais que:\\
\\
$left(\overline{p_i q_i}, p_{i-1}) \wedge left(\overline{p_i q_i}, q_{i+1})$\\
$\equiv$ \{ definição de left \}\\
$\mathcal{A}(p_i, q_i, p_{i-1}) > 0 \wedge \mathcal{A}(p_i, q_i, q_{i+1}) > 0$\\
$\equiv$ \{ regra dada na aula \}\\
$\mathcal{A}(p_{i-1}, p_i, q_i) > 0 \wedge \mathcal{A}(p_i, q_i, q_{i+1}) > 0$\\
(TODO por esta explicação em cima)\\

A função \textit{find\_higher\_lim} é análoga à \textit{find\_lower\_lim},
por isso arranjamos 2 vértices $p_i$ e $q_i$, tais que:\\
\\
$left(\overline{q_i p_i}, p_{i+1}) \wedge left(\overline{q_i p_i}, q_{i-1})$\\
$\equiv$ \{ definição de left \}\\
$\mathcal{A}(q_i, p_i, p_{i+1}) > 0 \wedge \mathcal{A}(q_i, p_i, q_{i-1}) > 0$\\
$\equiv$ \{ regra dada na aula \}\\
$\mathcal{A}(q_i, p_i, p_{i+1}) > 0 \wedge \mathcal{A}(q_{i-1}, q_i, p_i) > 0$\\

Com isto temos que os vértices encontrados que foram 
usados para juntar os dois invólucros são estritamente
convexos no $I(S)$. Como por indução sabemos que os 
outros vértices são estritamente convexos, significa
que todos os vértices em $I(S)$ são estritamente convexos.




\subsection{Todos os vértices estão no poligono}

Seja S o conjunto de pontos e P o invólucro convexo resultante.
Queremos provar que P contém todos os pontos de S.

Caso Base:
\begin{itemize}
    \item $P_1$ $\in \mathcal{R}^2$ e S = \{$P_1$\} e $P = P_1$ (TODO P é um conjunto)
    \item $P_1$,$P_2$ $\in \mathcal{R}^2$ e S = \{$P_1$,$P_2$\} e $P$ = \{$P_1$,$P_2$\} (TODO P é todos os pontos dentro do poligono)
    \item $P_1$,$P_2$,$P_3$ $\in \mathcal{R}^2$ e S = \{$P_1$,$P_2$,$P_3$\} 
        \newline
        \begin{itemize}
            \item Se os pontos forem colineares $(P1,P2 -> P3)$ 
                \newline
                onde $P_3 = P_1 + t(P_2 - P_1)$ para algum t $\in \mathcal{R}$
                \newline
                 temos que P = \{$P_1$,$P_2$\}(TODO P é todos os pontos dentro do poligono)

            \item Se os pontos não forem colineares  
                \newline
                 temos que P = \{$P_1$,$P_2$,$P_3$\}(TODO P é todos os pontos dentro do poligono)
        \end{itemize}
\end{itemize}

Casos Indutivos:
\newline
Supondo que S = $S_1 \cup S_2$ 
\newline
Onde $P_1$ contém todos os pontos de $S_1$ e $P_2$ contém todos os pontos
de $S_2$.
\newline

Seja $P_i$ a interseção da tangente superior com $P_1$, e $Q_i$ a interseção 
com $P_2$.(TODO o ponto mínimo)
E analogamente $P_j$ a interseção da tangente inferior com $P_1$
e $Q_j$ a interseção com $P_2$. (TODO o ponto máximo)

Depois de se juntar $P_1$ e $P_2$ cria-se apenas um invólucro convexo,
onde se pode dividir em 3 partes.(TODO é mesmo preciso dividir em 3?)

\begin{itemize}
    \item A) Todos os pontos de $S_1$ à esquerda de $P_jP_i$
    \item B) Poligno formado pelos pontos \{$P_i,Q_i,P_j,Q_j$\}
    \item C) Todos os pontos de $S_2$ à direita de $Q_jQ_i$
\end{itemize}

Queremos provar que:
\begin{itemize}
    \item $S_1 \subseteq A + B$
    \item $S_2 \subseteq B + C$
\end{itemize}

Sendo que $S_1$ pode ser repartipo em $A$ + $A_1$
\newline
Onde $A_1$ são os pontos de $S_1$ à direita de $P_iP_j$
\newline
Faltando apenas provar que $A_1 \subseteq B$ 
Por definição B contém os pontos à direita de $P_jP_i$ e à esquerda
de $Q_jQ_i$ e como os pontos são ordenados e divididos em P1 e P2
temos a garantia que a linha $Q_jQ_i$ está à direita de $P_jP_i$.
E uma fez que $P_i \in$ tangente superior, temos que todos os pontos
de $A_1$ estão abaixo dessa tangente, e analogamente todos os pontos
estão acima da tangente inferior.


Analogamete para $S_2 \subseteq B + C$
\hfill $\blacksquare$

\subsection{Proposição Tangente}
Seja 
    I um invólucro convexo e 
    l uma linha que interseta num vértice de I, $p_i$,
no sentido contrário dos ponteiros do relógio.
Seja $p_{i-1}$ o vértice anterior a $p_i$ e $p_{i+1}$ o vértice posterior a $p_i$.
Temos que:
$$leftOn(l, p_{i-1}) \wedge leftOn(l, p_{i+1}) \Rightarrow
    <\forall p : p \in I : leftOn(l, p)>$$

\subsubsection{Demonstração}
Suponhamos que $leftOn(l, p_{i-1}) \wedge leftOn(l, p_{i+1})$ 
e que existe um $p \in I$ tal que $right(l, p)$
isso significa que a linha $\overline{p\ p_i}$ não está no invólucro convexo.
Que é uma contradição, ou seja, $<\forall p : p \in I : leftOn(l, p)>$

\hfill $\blacksquare$
%--------------------------------------------


\section{Complexidade}
A nossa implementação não foi exatamente igual ao algoritmo original,
apesar de não alterar na conta da complexidade assintoticamente.
Por isso vamos avaliar a correção da nossa implementação, e quando 
achamos pertinente, vamos fazer a ressalva, mensionando as diferenças 
em relação ao algoritmo original.

\begin{itemize}
    \item Ordenar os pontos pela cordenada x, tem Complexidade $\Theta(n\log{}n)$
    \item Separar os pontos em dois conjuntos A e B, onde A contém os pontos da esquerda e B os da direita.
    \item Calcular o invólucro convexo de A, $\mathcal{A}$ = I(A) e o de B, $\mathcal{B}$ = I(B) recursivamente
    \item No final juntar $\mathcal{A}$ e $\mathcal{B}$, calculando o invólucro convexo de A $\cup$ B.
\end{itemize}

\subsection{Ordenar}
$$\Theta(n\log{}n)$$

\subsection{Separar}
$$\mathcal{O}(1)$$

\subsection{Encontrar}
$$\mathcal{O}(n)$$

\subsection{Juntar}
$$\mathcal{O}(1)$$

\subsection{Calcular invólucro}
$$
    \mathcal{T}(n) = 
        \begin{cases}
            \mathcal{O}(1)                      & n = 0\\
            \mathcal{O}(1)                      & n = 1\\
            \mathcal{O}(n) + 2*\mathcal{T}(n/2) & n > 1
        \end{cases}
$$

$$
    \mathcal{T}(n) = \sum_{i=0}^{\lfloor\log_{2}n\rfloor} 2^i*\mathcal{O}(n/2^i)
    = \sum_{i=0}^{\lfloor\log_{2}n\rfloor} \mathcal{O}(n)
    = (\lfloor\log_{2}n\rfloor + 1)*\mathcal{O}(n)
    = \mathcal{O}(n\log{n})
$$

%--------------------------------------------

\section{Conclusão}
\begin{itemize}
    \item O documento estava errado da complexidade.
    \item A parte de encontrar os limites pode ser mais eficiente, 
        mas a complexidade não mudaria, porque temos de ordenar.
    \item ...
\end{itemize}


\end{document}
