\documentclass[11pt]{article}
\usepackage{amssymb}
%\usepackage[all]{xy}

\title{Algoritmo para gerar invólucros convexos}
\author{Artur Queiroz - PG38014\\Luís Albuquerque - PG38015}
\begin{document}
\maketitle

\section{Introdução}
Neste trabalho abordamos um dos principais temas de Geometria 
Computacional, Invólucros Convexos.
Estes são muito usados porque têm aplicações em bastantes àreas
como reconhecimento de padrões, processamento de imagem, 
estatística, etc.

Existem várias formas de construir um, mas neste trabalho vamos
nos cingir a implementar o "\textit{merge-hull}"
Que é um algoritmo que se usa, umas das tecnicas mais importantes
na computação, que se chama "Dividir para conquistar".
Que se baseia em dividir um problema complexo, em problemas mais 
pequenos e mais faceis.

%--------------------------------------------
%\clearpage
\section{Descrição}
Para implementarmos o algoritmo apenas temos que seguir os passos
a baixo.

\begin{itemize}
    \item Ordenar os pontos por ordem lexicográfica.
    \item Remover os pontos repetidos.
    \item Criar o Invólucro convexo
    \begin{itemize}
        \item Se o conjunto tem apenas 1 elemento, criar um "polígono"
            de 1 elemento e acaba-se a função.
        \item Separar os pontos em dois conjuntos A e B, 
            onde A contem os pontos da esquerda e B os da direita.
        \item Calcular o invólucro convexo de A, 
            $\mathcal{A}$ = I(A) e o de B, $\mathcal{B}$ = I(B) recursivamente
        \item Encontrar o pontos de junção.
        \item Juntar $\mathcal{A}$ e $\mathcal{B}$, 
            calculando o invólucro convexo de A $\cup$ B.
    \end{itemize}
\end{itemize}

Agora vamos explicar com mais detalhe todo o processo.
\subsection{ Ordenar os Pontos }
Para ordenar os pontos, pode ser usado qualquer algoritmo de ordenação,
tendo em atenção que a escolha do algoritmo de ordenação, pode alterar a
complexidade do algoritmo como um todo.
Nós optamos por escolher o algoritmo de ordenação \textit{merge sort},
além de ter uma das melhores complexidades $\Theta(n\log{}n)$, achamos 
que se enquadra perfeitamente no espirito do algoritmo, "Dividir para conquistar".

\subsubsection{Descrição de MergeSort}
Input: array, indice esquerdo, indice direito\\

Começando com o indice esquerdo a 0, e o indice direito a (\textit{tamanho do array}) - 1
\begin{itemize}
    \item Primeiro encontra-se o indice médio do Array e divide-se em dois. 
        ( meio = (esquerda + direita)/2 )
    \item Calcular o MergeSort(array, esquerda, meio) (a lista que fica à esquerda)
    \item Calcular o MergeSort(array, meio+1, direita) (a lista que fica à direita)
    \item No final junta os dois de forma ordenada.
\end{itemize}

\subsection{ Remover os Pontos Repetidos }
Já que neste contexto sabemos que o array está ordenado,
podemos fazer este algoritmo com 2 indices, um para percorrer
o array, o outro para percorrer o novo array onde todos os 
elementos são diferentes. Se o valor dos dois indices for
diferente então incrementa-se o segundo indice e atribui-se
o valor do primeiro indice no valor do segundo indice. Se o 
valor dos dois indices for igual, apenas incrementa-se o
primeiro indice.

\subsection{ Separar os Pontos em dois conjuntos }
No trabalho decidimos usar um array, para que a sua divisão a meio 
tivesse uma complexidade constante é tão simples como encontrar o 
índice a meio do array.

\subsection{ Juntar os invólucros convexos } 
Liberta-se a memória dos vertices entre as duas ligações e de seguida 
conecta-se as duas ligações.

%--------------------------------------------

\section{Correção}
Depois de mostrarmos como é o algoritmo,
aqui vamos provar, porque é que o algoritmo faz o que diz que faz.

% Set -> Set   \item Ordenar os pontos por ordem lexicográfica.
% Set -> Set   \item Remover os pontos repetidos.
% Set -> Pol   \item Criar o Invólucro convexo
%    \begin{itemize}
% Set -> Pol       \item Se o conjunto tem apenas 1 elemento, criar um "polígono"
%            de 1 elemento e acaba-se a função.
% Set -> Set^2       \item Separar os pontos em dois conjuntos A e B, 
%            onde A contem os pontos da esquerda e B os da direita.
% Set^2 -> Pol^2       \item Calcular o invólucro convexo de A, 
%            $\mathcal{A}$ = I(A) e o de B, $\mathcal{B}$ = I(B) recursivamente
% Pol^2 -> Ver^4       \item Encontrar o pontos de junção.
% Ver^4*Pol^2 -> Pol       \item Juntar $\mathcal{A}$ e $\mathcal{B}$, 
%            calculando o invólucro convexo de A $\cup$ B.

\subsection{}
\textless forall s : s in Set : 
        \textless forall e,i : e in s $\wedge$ i in s : 
            line(i,e) in I(s)
        \textgreater 
\textgreater 


\hfill $\blacksquare$

%--------------------------------------------

\section{Complexidade}
A nossa implementação não foi exatamente igual ao algoritmo original,
apesar de não alterar na conta da complexidade assintoticamente.
Por isso vamos avaliar a correção da nossa implementação, e quando 
achamos pertinente, vamos fazer a ressalva, mensionando as diferenças 
em relação ao algoritmo original.

\begin{itemize}
    \item Ordenar os pontos pela cordenada x, tem Complexidade $\Theta(n\log{}n)$
    \item Separar os pontos em dois conjuntos A e B, onde A contém os pontos da esquerda e B os da direita.
    \item Calcular o invólucro convexo de A, $\mathcal{A}$ = I(A) e o de B, $\mathcal{B}$ = I(B) recursivamente
    \item No final juntar $\mathcal{A}$ e $\mathcal{B}$, calculando o invólucro convexo de A $\cup$ B.
\end{itemize}

%--------------------------------------------

\section{Conclusão}

\end{document}
