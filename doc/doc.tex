\documentclass[11pt]{article}
\usepackage{amssymb}
%\usepackage[all]{xy}

\title{Algoritmo para gerar invólucros convexos}
\author{Artur Queiroz - PG38014\\Luís Albuquerque - PG38015}
\begin{document}
\maketitle

\section{Introdução}
Neste trabalho abordamos um dos principais temas de Geometria 
Computacional, Invólucros Convexos.
Estes são muito usados porque têm aplicações em bastantes àreas
como reconhecimento de padrões, processamento de imagem, 
estatística, etc.

Existem várias formas de construir um, mas neste trabalho vamos
nos cingir a implementar o "\textit{merge-hull}"
Que é um algoritmo que se usa, umas das tecnicas mais importantes
na computação, que se chama "Dividir para conquistar".
Que se baseia em dividir um problema complexo, em problemas mais 
pequenos e mais faceis.

%--------------------------------------------
%\clearpage
\section{Descrição}
Para implementarmos o algoritmo apenas temos que seguir os passos
a baixo.

\begin{itemize}
    \item Ordenar os pontos por ordem lexicográfica.
    \item Remover os pontos repetidos.
    \item Criar o Invólucro convexo
    \begin{itemize}
        \item Se o conjunto tem apenas 1 elemento, criar um "polígono"
            de 1 elemento e acaba-se a função.
        \item Separar os pontos em dois conjuntos A e B, 
            onde A contém os pontos da esquerda e B os da direita.
        \item Calcular o invólucro convexo de A, 
            $\mathcal{A}$ = I(A) e o de B, $\mathcal{B}$ = I(B) recursivamente
        \item Encontrar o pontos de junção.
        \item Juntar $\mathcal{A}$ e $\mathcal{B}$, 
            calculando o invólucro convexo de A $\cup$ B.
    \end{itemize}
\end{itemize}

Agora vamos explicar com mais detalhe todo o processo.
\subsection{ Ordenar os Pontos }
Para ordenar os pontos, pode ser usado qualquer algoritmo de ordenação,
tendo em atenção que a escolha do algoritmo de ordenação, pode alterar a
complexidade do algoritmo como um todo.
Nós optamos por escolher o algoritmo de ordenação \textit{merge sort},
além de ter uma das melhores complexidades $\Theta(n\log{}n)$, achamos 
que se enquadra perfeitamente no espirito do algoritmo, "Dividir para conquistar".

\subsubsection{Descrição de MergeSort}
Input: array, indice esquerdo, indice direito\\

Começando com o indice esquerdo a 0, e o indice direito a (\textit{tamanho do array}) - 1
\begin{itemize}
    \item Primeiro encontra-se o indice médio do Array e divide-se em dois. 
        ( meio = (esquerda + direita)/2 )
    \item Calcular o MergeSort(array, esquerda, meio) (a lista que fica à esquerda)
    \item Calcular o MergeSort(array, meio+1, direita) (a lista que fica à direita)
    \item No final junta os dois de forma ordenada.
\end{itemize}

\subsection{ Remover os Pontos Repetidos }
Já que neste contexto sabemos que o array está ordenado,
podemos fazer este algoritmo com 2 indices, um para percorrer
o array, o outro para percorrer o novo array onde todos os 
elementos são diferentes. Se o valor dos dois indices for
diferente então incrementa-se o segundo indice e atribui-se
o valor do primeiro indice no valor do segundo indice. Se o 
valor dos dois indices for igual, apenas incrementa-se o
primeiro indice.

\subsection{ Separar os Pontos em dois conjuntos }
No trabalho decidimos usar um array, para que a sua divisão a meio 
tivesse uma complexidade constante é tão simples como encontrar o 
índice a meio do array.

\subsection{ Juntar os invólucros convexos } 
Liberta-se a memória dos vértices entre as duas ligações e de seguida 
conecta-se as duas ligações.

%--------------------------------------------

\section{Correção}
Depois de mostrarmos como é o algoritmo,
aqui vamos provar, porque é que o algoritmo faz o que diz que faz.
Tendo I como a nossa função descrita em cima.\\
\\
Queremos que no fim de execução do algoritmo, o poligono
retornado seja o invólucro convexo do conjunto dado 
no input.\par
Para isso vamos usar um Corolário dado nas aulas, descrito como:

\begin{center}
    "Seja $S \subseteq \mathbb{R}^2$ e $P$ um poligono de vértices 
    positivamente orientados $v_0,...,v_{n-1} \in S$ tal que cada
    vértice é estritamente convexo e $S \subseteq P$. Então $P$ é
    o invólucro convexo de S."
\end{center}

E a definição:

\begin{center}
    "$v_i$ diz-se estritamente convexo se $\mathcal{A}(v_{i-1},v_i,v_{i+1}) > 0$."
\end{center}

Agora para provar que o nosso algoritmo retorna o invólucro convexo
do conjunto dado no input, basta provar que o poligono retornado,
com os vértices positivamente orientados, tem todos os vértices 
estritamente convexos e contém todo o conjunto de pontos.\\

[Provar para os casos base 0, 1 e 2]

\subsection{Todos os vértices são estritamente convexos}

Seja S o conjunto de pontos dado no input.\\

caso indutivo:\\
Seja $S = S_1 \cup S_2$ tal que todos os pontos de $S_1$
sejam menores que os pontos de $S_2$ (lexicograficamente).\\
Hipoteses Indutivas:
\begin{enumerate}
    \item $< \forall p_i : p_i \in I(S_1) : \mathcal{A}(p_{i-1}, p_i, p_{i+1}) > 0 >$
    \item $< \forall p_i : p_i \in I(S_2) : \mathcal{A}(p_{i-1}, p_i, p_{i+1}) > 0 >$
\end{enumerate}

Na função \textit{find\_lower\_lim} começa-se com a linha,
do maior vértice de $I(S_1)$ ao menor vértice de $I(S_2)$ (lexicograficamente).
A partir do vértice atual de $I(S_1)$ segue-se para o anterior, o mais 
longe possível, até que o vértice anterior esteja estritamente à
esquerda da linha, de seguida fazemos o dual para o vértice de $I(S_2)$.
Repetindo este processo até não se conseguir mais.\par
Quando não conseguirmos mais, significa que encontramos 2 vértices 
$p_i$ e $q_i$, tais que:\\
\\
$left(\overline{p_i q_i}, p_{i-1}) \wedge left(\overline{p_i q_i}, q_{i+1})$\\
$\equiv$ \{ definição de left \}\\
$\mathcal{A}(p_i, q_i, p_{i-1}) > 0 \wedge \mathcal{A}(p_i, q_i, q_{i+1}) > 0$\\
$\equiv$ \{ regra dada na aula \}\\
$\mathcal{A}(p_{i-1}, p_i, q_i) > 0 \wedge \mathcal{A}(p_i, q_i, q_{i+1}) > 0$\\

A função \textit{find\_higher\_lim} é análoga à \textit{find\_lower\_lim},
por isso arranjamos 2 vértices $p_i$ e $q_i$, tais que:\\
\\
$left(\overline{q_i p_i}, p_{i+1}) \wedge left(\overline{q_i p_i}, q_{i-1})$\\
$\equiv$ \{ definição de left \}\\
$\mathcal{A}(q_i, p_i, p_{i+1}) > 0 \wedge \mathcal{A}(q_i, p_i, q_{i-1}) > 0$\\
$\equiv$ \{ regra dada na aula \}\\
$\mathcal{A}(q_i, p_i, p_{i+1}) > 0 \wedge \mathcal{A}(q_{i-1}, q_i, p_i) > 0$\\

Com isto temos que os vértices encontrados que foram 
usados para juntar os dois invólucros são estritamente
convexos no $I(S)$. Como por indução sabemos que os 
outros vértices são estritamente convexos, significa
que todos os vértices em $I(S)$ são estritamente convexos.



\hfill $\blacksquare$

\subsection{Todos os vértices são estão contidos no poligono}

Seja S o conjunto de pontos e P o involucro convexo resultante.
Queremos provar que P contém todos os pontos de S.

Caso Base:
\begin{itemize}
    \item $P_1$ $\in \mathcal{R}^2$ e S = \{$P_1$\} e $P = P_1$
    \item $P_1$,$P_2$ $\in \mathcal{R}^2$ e S = \{$P_1$,$P_2$\} e $P$ = \{$P_1$,$P_2$\}
    \item $P_1$,$P_2$,$P_3$ $\in \mathcal{R}^2$ e S = \{$P_1$,$P_2$,$P_3$\} 
        \newline
        \begin{itemize}
            \item Se os pontos forem colineares $(P1,P2 -> P3)$ 
                \newline
                onde $P_3 = P_1 + (P_2 - P_1)t$ com t $\in \mathcal{R}$
                \newline
                 temos que P = \{$P_1$,$P_2$\}

            \item Se os pontos não forem colineares  
                \newline
                 temos que P = \{$P_1$,$P_2$,$P_3$\}
        \end{itemize}
\end{itemize}

Casos Indutivos:
\newline
Supondo que S = $S_1 \cup S_2$ 
\newline
Onde $P_1$ contém todos os pontos de $S_1$ e $P_2$ contém todos ps pontos
de $S_2$.
\newline

Seja $P_i$ a intrecepção da tangente superior com $P_1$, e $Q_i$ a intrecepção 
com $P_2$.
E analogamente $P_j$ a intrecepção da tangente inferior com $P_1$
e $Q_j$ a intrecepção com $P_2$.

Depois de Se juntar $P_1$ e $P_2$ cria-se apenas um Involucro convexo,
onde se pode dividir em 3 partes.

\begin{itemize}
    \item A) Todos os pontos de $S_1$ à esquerda de $P_jP_i$
    \item B) Poligno formado pelos pontos \{$P_i,Q_i,P_j,Q_j$\}
    \item C) Todos os pontos de $S_2$ à direita de $Q_jQ_i$
\end{itemize}

Queremos provar que:
\begin{itemize}
    \item $S_1 \subseteq A + B$
    \item $S_2 \subseteq B + C$
\end{itemize}

Sendo que $S_1$ pode ser repartipo em $A$ + $A_1$
\newline
Onde $A_1$ são os pontos de $S_1$ à direita de $P_iP_j$
\newline
Faltando apenas provar que $A_1 \subseteq B$ 
Por definição B contém os pontos à direita de $P_jP_i$ e à esquerda
de $Q_jQ_i$ e como os pontos são ordenados e divididos em P1 e P2
temos a garantia que a linha $Q_jQ_i$ está à direita de $P_jP_i$.
E uma fez que $P_i \in$ tangente superior, temos que todos os pontos
de $A_1$ estão abaixo dessa tangente, e analogamente todos os pontos
estão acima da tangente inferior.


Analogamete para $S_2 \subseteq B + C$

\subsection{Proposição Tangente}
Seja 
    I um invólucro convexo e 
    l uma linha que interseta num vértice de I, $p_i$,
no sentido contrário dos ponteiros do relógio.
Seja $p_{i-1}$ o vértice anterior a $p_i$ e $p_{i+1}$ o vértice posterior a $p_i$.
Temos que:
$$leftOn(l, p_{i-1}) \wedge leftOn(l, p_{i+1}) \Rightarrow
    <\forall p : p \in I : leftOn(l, p)>$$

\subsubsection{Demonstração}
Suponhamos que $leftOn(l, p_{i-1}) \wedge leftOn(l, p_{i+1})$ 
e que existe um $p \in I$ tal que $right(l, p)$
isso significa que a linha $\overline{p\ p_i}$ não está no invólucro convexo.
Que é uma contradição, ou seja, $<\forall p : p \in I : leftOn(l, p)>$

%--------------------------------------------


\section{Complexidade}
A nossa implementação não foi exatamente igual ao algoritmo original,
apesar de não alterar na conta da complexidade assintoticamente.
Por isso vamos avaliar a correção da nossa implementação, e quando 
achamos pertinente, vamos fazer a ressalva, mensionando as diferenças 
em relação ao algoritmo original.

\begin{itemize}
    \item Ordenar os pontos pela cordenada x, tem Complexidade $\Theta(n\log{}n)$
    \item Separar os pontos em dois conjuntos A e B, onde A contém os pontos da esquerda e B os da direita.
    \item Calcular o invólucro convexo de A, $\mathcal{A}$ = I(A) e o de B, $\mathcal{B}$ = I(B) recursivamente
    \item No final juntar $\mathcal{A}$ e $\mathcal{B}$, calculando o invólucro convexo de A $\cup$ B.
\end{itemize}

%--------------------------------------------

\section{Conclusão}

\end{document}
